{"ast":null,"code":"\"use strict\";\n\nimport Color from 'color';\nimport * as React from 'react';\nimport Animated from \"react-native-web/dist/exports/Animated\";\nimport InteractionManager from \"react-native-web/dist/exports/InteractionManager\";\nimport Platform from \"react-native-web/dist/exports/Platform\";\nimport StyleSheet from \"react-native-web/dist/exports/StyleSheet\";\nimport View from \"react-native-web/dist/exports/View\";\nimport useLatestCallback from 'use-latest-callback';\nimport { CardAnimationContext } from \"../../utils/CardAnimationContext.js\";\nimport { gestureActivationCriteria } from \"../../utils/gestureActivationCriteria.js\";\nimport { getDistanceForDirection } from \"../../utils/getDistanceForDirection.js\";\nimport { getInvertedMultiplier } from \"../../utils/getInvertedMultiplier.js\";\nimport { getShadowStyle } from \"../../utils/getShadowStyle.js\";\nimport { GestureState, PanGestureHandler } from '../GestureHandler';\nimport { CardContent } from \"./CardContent.js\";\nimport { jsx as _jsx, jsxs as _jsxs } from \"react/jsx-runtime\";\nconst GESTURE_VELOCITY_IMPACT = 0.3;\nconst TRUE = 1;\nconst FALSE = 0;\nconst useNativeDriver = Platform.OS !== 'web';\nconst hasOpacityStyle = style => {\n  if (style) {\n    const flattenedStyle = StyleSheet.flatten(style);\n    return 'opacity' in flattenedStyle && flattenedStyle.opacity != null;\n  }\n  return false;\n};\nconst getAnimateToValue = ({\n  closing: isClosing,\n  layout: currentLayout,\n  gestureDirection: currentGestureDirection,\n  direction: currentDirection,\n  preloaded: isPreloaded\n}) => {\n  if (!isClosing && !isPreloaded) {\n    return 0;\n  }\n  return getDistanceForDirection(currentLayout, currentGestureDirection, currentDirection === 'rtl');\n};\nconst defaultOverlay = ({\n  style\n}) => style ? _jsx(Animated.View, {\n  pointerEvents: \"none\",\n  style: [styles.overlay, style]\n}) : null;\nfunction Card({\n  shadowEnabled = false,\n  gestureEnabled = true,\n  gestureVelocityImpact = GESTURE_VELOCITY_IMPACT,\n  overlay = defaultOverlay,\n  animated,\n  interpolationIndex,\n  opening,\n  closing,\n  next,\n  current,\n  gesture,\n  layout,\n  insets,\n  direction,\n  pageOverflowEnabled,\n  gestureDirection,\n  onOpen,\n  onClose,\n  onTransition,\n  onGestureBegin,\n  onGestureCanceled,\n  onGestureEnd,\n  children,\n  overlayEnabled,\n  gestureResponseDistance,\n  transitionSpec,\n  preloaded,\n  styleInterpolator,\n  containerStyle: customContainerStyle,\n  contentStyle\n}) {\n  const [, forceUpdate] = React.useReducer(x => x + 1, 0);\n  const didInitiallyAnimate = React.useRef(false);\n  const lastToValueRef = React.useRef(undefined);\n  const interactionHandleRef = React.useRef(undefined);\n  const animationHandleRef = React.useRef(undefined);\n  const pendingGestureCallbackRef = React.useRef(undefined);\n  const [isClosing] = React.useState(() => new Animated.Value(FALSE));\n  const [inverted] = React.useState(() => new Animated.Value(getInvertedMultiplier(gestureDirection, direction === 'rtl')));\n  const [layoutAnim] = React.useState(() => ({\n    width: new Animated.Value(layout.width),\n    height: new Animated.Value(layout.height)\n  }));\n  const [isSwiping] = React.useState(() => new Animated.Value(FALSE));\n  const onStartInteraction = useLatestCallback(() => {\n    if (interactionHandleRef.current === undefined) {\n      interactionHandleRef.current = InteractionManager.createInteractionHandle();\n    }\n  });\n  const onEndInteraction = useLatestCallback(() => {\n    if (interactionHandleRef.current !== undefined) {\n      InteractionManager.clearInteractionHandle(interactionHandleRef.current);\n      interactionHandleRef.current = undefined;\n    }\n  });\n  const animate = useLatestCallback(({\n    closing: isClosingParam,\n    velocity\n  }) => {\n    const toValue = getAnimateToValue({\n      closing: isClosingParam,\n      layout,\n      gestureDirection,\n      direction,\n      preloaded\n    });\n    lastToValueRef.current = toValue;\n    isClosing.setValue(isClosingParam ? TRUE : FALSE);\n    const spec = isClosingParam ? transitionSpec.close : transitionSpec.open;\n    const animation = spec.animation === 'spring' ? Animated.spring : Animated.timing;\n    clearTimeout(pendingGestureCallbackRef.current);\n    if (animationHandleRef.current !== undefined) {\n      cancelAnimationFrame(animationHandleRef.current);\n    }\n    onTransition?.({\n      closing: isClosingParam,\n      gesture: velocity !== undefined\n    });\n    const onFinish = () => {\n      if (isClosingParam) {\n        onClose();\n      } else {\n        onOpen();\n      }\n      animationHandleRef.current = requestAnimationFrame(() => {\n        if (didInitiallyAnimate.current) {\n          forceUpdate();\n        }\n      });\n    };\n    if (animated) {\n      onStartInteraction();\n      animation(gesture, Object.assign({}, spec.config, {\n        velocity,\n        toValue,\n        useNativeDriver,\n        isInteraction: false\n      })).start(({\n        finished\n      }) => {\n        onEndInteraction();\n        clearTimeout(pendingGestureCallbackRef.current);\n        if (finished) {\n          onFinish();\n        }\n      });\n    } else {\n      onFinish();\n    }\n  });\n  const onGestureStateChange = useLatestCallback(({\n    nativeEvent\n  }) => {\n    switch (nativeEvent.state) {\n      case GestureState.ACTIVE:\n        isSwiping.setValue(TRUE);\n        onStartInteraction();\n        onGestureBegin?.();\n        break;\n      case GestureState.CANCELLED:\n      case GestureState.FAILED:\n        {\n          isSwiping.setValue(FALSE);\n          onEndInteraction();\n          const velocity = gestureDirection === 'vertical' || gestureDirection === 'vertical-inverted' ? nativeEvent.velocityY : nativeEvent.velocityX;\n          animate({\n            closing,\n            velocity\n          });\n          onGestureCanceled?.();\n          break;\n        }\n      case GestureState.END:\n        {\n          isSwiping.setValue(FALSE);\n          let distance;\n          let translation;\n          let velocity;\n          if (gestureDirection === 'vertical' || gestureDirection === 'vertical-inverted') {\n            distance = layout.height;\n            translation = nativeEvent.translationY;\n            velocity = nativeEvent.velocityY;\n          } else {\n            distance = layout.width;\n            translation = nativeEvent.translationX;\n            velocity = nativeEvent.velocityX;\n          }\n          const shouldClose = (translation + velocity * gestureVelocityImpact) * getInvertedMultiplier(gestureDirection, direction === 'rtl') > distance / 2 ? velocity !== 0 || translation !== 0 : closing;\n          animate({\n            closing: shouldClose,\n            velocity\n          });\n          if (shouldClose) {\n            pendingGestureCallbackRef.current = setTimeout(() => {\n              onClose();\n              forceUpdate();\n            }, 32);\n          }\n          onGestureEnd?.();\n          break;\n        }\n    }\n  });\n  React.useLayoutEffect(() => {\n    layoutAnim.width.setValue(layout.width);\n    layoutAnim.height.setValue(layout.height);\n    inverted.setValue(getInvertedMultiplier(gestureDirection, direction === 'rtl'));\n  }, [gestureDirection, direction, inverted, layoutAnim.width, layoutAnim.height, layout.width, layout.height]);\n  const previousPropsRef = React.useRef(null);\n  React.useEffect(() => {\n    return () => {\n      onEndInteraction();\n      if (animationHandleRef.current) {\n        cancelAnimationFrame(animationHandleRef.current);\n      }\n      clearTimeout(pendingGestureCallbackRef.current);\n    };\n  }, []);\n  const timeoutRef = React.useRef(null);\n  React.useEffect(() => {\n    if (preloaded) {\n      return;\n    }\n    if (!didInitiallyAnimate.current) {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      timeoutRef.current = setTimeout(() => {\n        didInitiallyAnimate.current = true;\n        animate({\n          closing\n        });\n      }, 0);\n    } else {\n      const previousOpening = previousPropsRef.current?.opening;\n      const previousToValue = previousPropsRef.current ? getAnimateToValue(previousPropsRef.current) : null;\n      const toValue = getAnimateToValue({\n        closing,\n        layout,\n        gestureDirection,\n        direction,\n        preloaded\n      });\n      if (previousToValue !== toValue || lastToValueRef.current !== toValue) {\n        animate({\n          closing\n        });\n      } else if (typeof previousOpening === 'boolean' && opening && !previousOpening) {\n        gesture.setValue(getDistanceForDirection(layout, gestureDirection, direction === 'rtl'));\n        animate({\n          closing\n        });\n      }\n    }\n    previousPropsRef.current = {\n      opening,\n      closing,\n      layout,\n      gestureDirection,\n      direction,\n      preloaded\n    };\n  }, [animate, closing, direction, gesture, gestureDirection, layout, opening, preloaded]);\n  const interpolationProps = React.useMemo(() => ({\n    index: interpolationIndex,\n    current: {\n      progress: current\n    },\n    next: next && {\n      progress: next\n    },\n    closing: isClosing,\n    swiping: isSwiping,\n    inverted,\n    layouts: {\n      screen: layout\n    },\n    insets: {\n      top: insets.top,\n      right: insets.right,\n      bottom: insets.bottom,\n      left: insets.left\n    }\n  }), [interpolationIndex, current, next, isClosing, isSwiping, inverted, layout, insets.top, insets.right, insets.bottom, insets.left]);\n  const {\n    containerStyle,\n    cardStyle,\n    overlayStyle,\n    shadowStyle\n  } = React.useMemo(() => styleInterpolator(interpolationProps), [styleInterpolator, interpolationProps]);\n  const onGestureEvent = React.useMemo(() => gestureEnabled ? Animated.event([{\n    nativeEvent: gestureDirection === 'vertical' || gestureDirection === 'vertical-inverted' ? {\n      translationY: gesture\n    } : {\n      translationX: gesture\n    }\n  }], {\n    useNativeDriver\n  }) : undefined, [gesture, gestureDirection, gestureEnabled]);\n  const {\n    backgroundColor\n  } = StyleSheet.flatten(contentStyle || {});\n  const isTransparent = typeof backgroundColor === 'string' ? Color(backgroundColor).alpha() === 0 : false;\n  return _jsxs(CardAnimationContext.Provider, {\n    value: interpolationProps,\n    children: [Platform.OS !== 'web' ? _jsx(Animated.View, {\n      style: {\n        opacity: current\n      },\n      collapsable: false\n    }) : null, overlayEnabled ? _jsx(View, {\n      pointerEvents: \"box-none\",\n      style: StyleSheet.absoluteFill,\n      children: overlay({\n        style: overlayStyle\n      })\n    }) : null, _jsx(Animated.View, {\n      pointerEvents: \"box-none\",\n      style: [styles.container, containerStyle, customContainerStyle],\n      children: _jsx(PanGestureHandler, Object.assign({\n        enabled: layout.width !== 0 && gestureEnabled,\n        onGestureEvent: onGestureEvent,\n        onHandlerStateChange: onGestureStateChange\n      }, gestureActivationCriteria({\n        layout,\n        direction,\n        gestureDirection,\n        gestureResponseDistance\n      }), {\n        children: _jsxs(Animated.View, {\n          pointerEvents: \"box-none\",\n          needsOffscreenAlphaCompositing: hasOpacityStyle(cardStyle),\n          style: [styles.container, cardStyle],\n          children: [shadowEnabled && shadowStyle && !isTransparent ? _jsx(Animated.View, {\n            pointerEvents: \"none\",\n            style: [styles.shadow, gestureDirection === 'horizontal' ? [styles.shadowHorizontal, styles.shadowStart] : gestureDirection === 'horizontal-inverted' ? [styles.shadowHorizontal, styles.shadowEnd] : gestureDirection === 'vertical' ? [styles.shadowVertical, styles.shadowTop] : [styles.shadowVertical, styles.shadowBottom], {\n              backgroundColor\n            }, shadowStyle]\n          }) : null, _jsx(CardContent, {\n            enabled: pageOverflowEnabled,\n            layout: layout,\n            style: contentStyle,\n            children: children\n          })]\n        })\n      }))\n    })]\n  });\n}\nexport { Card };\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1\n  },\n  overlay: {\n    flex: 1,\n    backgroundColor: '#000'\n  },\n  shadow: {\n    position: 'absolute'\n  },\n  shadowHorizontal: Object.assign({\n    top: 0,\n    bottom: 0,\n    width: 3\n  }, getShadowStyle({\n    offset: {\n      width: -1,\n      height: 1\n    },\n    radius: 5,\n    opacity: 0.3\n  })),\n  shadowStart: {\n    start: 0\n  },\n  shadowEnd: {\n    end: 0\n  },\n  shadowVertical: Object.assign({\n    start: 0,\n    end: 0,\n    height: 3\n  }, getShadowStyle({\n    offset: {\n      width: 1,\n      height: -1\n    },\n    radius: 5,\n    opacity: 0.3\n  })),\n  shadowTop: {\n    top: 0\n  },\n  shadowBottom: {\n    bottom: 0\n  }\n});","map":{"version":3,"names":["Color","React","Animated","InteractionManager","Platform","StyleSheet","View","useLatestCallback","CardAnimationContext","gestureActivationCriteria","getDistanceForDirection","getInvertedMultiplier","getShadowStyle","GestureState","PanGestureHandler","CardContent","jsx","_jsx","jsxs","_jsxs","GESTURE_VELOCITY_IMPACT","TRUE","FALSE","useNativeDriver","OS","hasOpacityStyle","style","flattenedStyle","flatten","opacity","getAnimateToValue","closing","isClosing","layout","currentLayout","gestureDirection","currentGestureDirection","direction","currentDirection","preloaded","isPreloaded","defaultOverlay","pointerEvents","styles","overlay","Card","shadowEnabled","gestureEnabled","gestureVelocityImpact","animated","interpolationIndex","opening","next","current","gesture","insets","pageOverflowEnabled","onOpen","onClose","onTransition","onGestureBegin","onGestureCanceled","onGestureEnd","children","overlayEnabled","gestureResponseDistance","transitionSpec","styleInterpolator","containerStyle","customContainerStyle","contentStyle","forceUpdate","useReducer","x","didInitiallyAnimate","useRef","lastToValueRef","undefined","interactionHandleRef","animationHandleRef","pendingGestureCallbackRef","useState","Value","inverted","layoutAnim","width","height","isSwiping","onStartInteraction","createInteractionHandle","onEndInteraction","clearInteractionHandle","animate","isClosingParam","velocity","toValue","setValue","spec","close","open","animation","spring","timing","clearTimeout","cancelAnimationFrame","onFinish","requestAnimationFrame","Object","assign","config","isInteraction","start","finished","onGestureStateChange","nativeEvent","state","ACTIVE","CANCELLED","FAILED","velocityY","velocityX","END","distance","translation","translationY","translationX","shouldClose","setTimeout","useLayoutEffect","previousPropsRef","useEffect","timeoutRef","previousOpening","previousToValue","interpolationProps","useMemo","index","progress","swiping","layouts","screen","top","right","bottom","left","cardStyle","overlayStyle","shadowStyle","onGestureEvent","event","backgroundColor","isTransparent","alpha","Provider","value","collapsable","absoluteFill","container","enabled","onHandlerStateChange","needsOffscreenAlphaCompositing","shadow","shadowHorizontal","shadowStart","shadowEnd","shadowVertical","shadowTop","shadowBottom","create","flex","position","offset","radius","end"],"sources":["C:\\Users\\Devi\\support-app\\mobile\\node_modules\\@react-navigation\\stack\\src\\views\\Stack\\Card.tsx"],"sourcesContent":["import type { LocaleDirection } from '@react-navigation/native';\nimport Color from 'color';\nimport * as React from 'react';\nimport {\n  Animated,\n  InteractionManager,\n  Platform,\n  type StyleProp,\n  StyleSheet,\n  View,\n  type ViewStyle,\n} from 'react-native';\nimport type { EdgeInsets } from 'react-native-safe-area-context';\nimport useLatestCallback from 'use-latest-callback';\n\nimport type {\n  GestureDirection,\n  Layout,\n  StackCardStyleInterpolator,\n  TransitionSpec,\n} from '../../types';\nimport { CardAnimationContext } from '../../utils/CardAnimationContext';\nimport { gestureActivationCriteria } from '../../utils/gestureActivationCriteria';\nimport { getDistanceForDirection } from '../../utils/getDistanceForDirection';\nimport { getInvertedMultiplier } from '../../utils/getInvertedMultiplier';\nimport { getShadowStyle } from '../../utils/getShadowStyle';\nimport {\n  GestureState,\n  PanGestureHandler,\n  type PanGestureHandlerGestureEvent,\n} from '../GestureHandler';\nimport { CardContent } from './CardContent';\n\ntype Props = {\n  animated: boolean;\n  interpolationIndex: number;\n  opening: boolean;\n  closing: boolean;\n  next: Animated.AnimatedInterpolation<number> | undefined;\n  current: Animated.AnimatedInterpolation<number>;\n  gesture: Animated.Value;\n  layout: Layout;\n  insets: EdgeInsets;\n  direction: LocaleDirection;\n  pageOverflowEnabled: boolean;\n  gestureDirection: GestureDirection;\n  onOpen: () => void;\n  onClose: () => void;\n  onTransition: (props: { closing: boolean; gesture: boolean }) => void;\n  onGestureBegin: () => void;\n  onGestureCanceled: () => void;\n  onGestureEnd: () => void;\n  children: React.ReactNode;\n  overlay:\n    | ((props: {\n        style: Animated.WithAnimatedValue<StyleProp<ViewStyle>>;\n      }) => React.ReactNode)\n    | undefined;\n  overlayEnabled: boolean;\n  shadowEnabled: boolean | undefined;\n  gestureEnabled: boolean;\n  gestureResponseDistance?: number;\n  gestureVelocityImpact: number | undefined;\n  transitionSpec: {\n    open: TransitionSpec;\n    close: TransitionSpec;\n  };\n  preloaded: boolean;\n  styleInterpolator: StackCardStyleInterpolator;\n  containerStyle?: StyleProp<ViewStyle>;\n  contentStyle?: StyleProp<ViewStyle>;\n};\n\nconst GESTURE_VELOCITY_IMPACT = 0.3;\n\nconst TRUE = 1;\nconst FALSE = 0;\n\nconst useNativeDriver = Platform.OS !== 'web';\n\nconst hasOpacityStyle = (\n  style: Animated.WithAnimatedValue<StyleProp<ViewStyle>>\n) => {\n  if (style) {\n    const flattenedStyle = StyleSheet.flatten(style);\n\n    return 'opacity' in flattenedStyle && flattenedStyle.opacity != null;\n  }\n\n  return false;\n};\n\nconst getAnimateToValue = ({\n  closing: isClosing,\n  layout: currentLayout,\n  gestureDirection: currentGestureDirection,\n  direction: currentDirection,\n  preloaded: isPreloaded,\n}: {\n  closing?: boolean;\n  layout: Layout;\n  gestureDirection: GestureDirection;\n  direction: LocaleDirection;\n  preloaded: boolean;\n}) => {\n  if (!isClosing && !isPreloaded) {\n    return 0;\n  }\n\n  return getDistanceForDirection(\n    currentLayout,\n    currentGestureDirection,\n    currentDirection === 'rtl'\n  );\n};\n\nconst defaultOverlay = ({\n  style,\n}: {\n  style: Animated.WithAnimatedValue<StyleProp<ViewStyle>>;\n}) =>\n  style ? (\n    <Animated.View pointerEvents=\"none\" style={[styles.overlay, style]} />\n  ) : null;\n\nfunction Card({\n  shadowEnabled = false,\n  gestureEnabled = true,\n  gestureVelocityImpact = GESTURE_VELOCITY_IMPACT,\n  overlay = defaultOverlay,\n  animated,\n  interpolationIndex,\n  opening,\n  closing,\n  next,\n  current,\n  gesture,\n  layout,\n  insets,\n  direction,\n  pageOverflowEnabled,\n  gestureDirection,\n  onOpen,\n  onClose,\n  onTransition,\n  onGestureBegin,\n  onGestureCanceled,\n  onGestureEnd,\n  children,\n  overlayEnabled,\n  gestureResponseDistance,\n  transitionSpec,\n  preloaded,\n  styleInterpolator,\n  containerStyle: customContainerStyle,\n  contentStyle,\n}: Props) {\n  const [, forceUpdate] = React.useReducer((x) => x + 1, 0);\n\n  const didInitiallyAnimate = React.useRef(false);\n  const lastToValueRef = React.useRef<number | undefined>(undefined);\n\n  const interactionHandleRef = React.useRef<number | undefined>(undefined);\n  const animationHandleRef = React.useRef<number | undefined>(undefined);\n  const pendingGestureCallbackRef =\n    React.useRef<ReturnType<typeof setTimeout>>(undefined);\n\n  const [isClosing] = React.useState(() => new Animated.Value(FALSE));\n\n  const [inverted] = React.useState(\n    () =>\n      new Animated.Value(\n        getInvertedMultiplier(gestureDirection, direction === 'rtl')\n      )\n  );\n\n  const [layoutAnim] = React.useState(() => ({\n    width: new Animated.Value(layout.width),\n    height: new Animated.Value(layout.height),\n  }));\n\n  const [isSwiping] = React.useState(() => new Animated.Value(FALSE));\n\n  const onStartInteraction = useLatestCallback(() => {\n    if (interactionHandleRef.current === undefined) {\n      interactionHandleRef.current =\n        InteractionManager.createInteractionHandle();\n    }\n  });\n\n  const onEndInteraction = useLatestCallback(() => {\n    if (interactionHandleRef.current !== undefined) {\n      InteractionManager.clearInteractionHandle(interactionHandleRef.current);\n      interactionHandleRef.current = undefined;\n    }\n  });\n\n  const animate = useLatestCallback(\n    ({\n      closing: isClosingParam,\n      velocity,\n    }: {\n      closing: boolean;\n      velocity?: number;\n    }) => {\n      const toValue = getAnimateToValue({\n        closing: isClosingParam,\n        layout,\n        gestureDirection,\n        direction,\n        preloaded,\n      });\n\n      lastToValueRef.current = toValue;\n      isClosing.setValue(isClosingParam ? TRUE : FALSE);\n\n      const spec = isClosingParam ? transitionSpec.close : transitionSpec.open;\n      const animation =\n        spec.animation === 'spring' ? Animated.spring : Animated.timing;\n\n      clearTimeout(pendingGestureCallbackRef.current);\n\n      if (animationHandleRef.current !== undefined) {\n        cancelAnimationFrame(animationHandleRef.current);\n      }\n\n      onTransition?.({\n        closing: isClosingParam,\n        gesture: velocity !== undefined,\n      });\n\n      const onFinish = () => {\n        if (isClosingParam) {\n          onClose();\n        } else {\n          onOpen();\n        }\n\n        animationHandleRef.current = requestAnimationFrame(() => {\n          if (didInitiallyAnimate.current) {\n            // Make sure to re-open screen if it wasn't removed\n            forceUpdate();\n          }\n        });\n      };\n\n      if (animated) {\n        onStartInteraction();\n        animation(gesture, {\n          ...spec.config,\n          velocity,\n          toValue,\n          useNativeDriver,\n          isInteraction: false,\n        }).start(({ finished }) => {\n          onEndInteraction();\n          clearTimeout(pendingGestureCallbackRef.current);\n\n          if (finished) {\n            onFinish();\n          }\n        });\n      } else {\n        onFinish();\n      }\n    }\n  );\n\n  const onGestureStateChange = useLatestCallback(\n    ({ nativeEvent }: PanGestureHandlerGestureEvent) => {\n      switch (nativeEvent.state) {\n        case GestureState.ACTIVE:\n          isSwiping.setValue(TRUE);\n          onStartInteraction();\n          onGestureBegin?.();\n          break;\n        case GestureState.CANCELLED:\n        case GestureState.FAILED: {\n          isSwiping.setValue(FALSE);\n          onEndInteraction();\n\n          const velocity =\n            gestureDirection === 'vertical' ||\n            gestureDirection === 'vertical-inverted'\n              ? nativeEvent.velocityY\n              : nativeEvent.velocityX;\n\n          animate({\n            closing,\n            velocity,\n          });\n\n          onGestureCanceled?.();\n          break;\n        }\n        case GestureState.END: {\n          isSwiping.setValue(FALSE);\n\n          let distance;\n          let translation;\n          let velocity;\n\n          if (\n            gestureDirection === 'vertical' ||\n            gestureDirection === 'vertical-inverted'\n          ) {\n            distance = layout.height;\n            translation = nativeEvent.translationY;\n            velocity = nativeEvent.velocityY;\n          } else {\n            distance = layout.width;\n            translation = nativeEvent.translationX;\n            velocity = nativeEvent.velocityX;\n          }\n\n          const shouldClose =\n            (translation + velocity * gestureVelocityImpact) *\n              getInvertedMultiplier(gestureDirection, direction === 'rtl') >\n            distance / 2\n              ? velocity !== 0 || translation !== 0\n              : closing;\n\n          animate({ closing: shouldClose, velocity });\n\n          if (shouldClose) {\n            // We call onClose with a delay to make sure that the animation has already started\n            // This will make sure that the state update caused by this doesn't affect start of animation\n            pendingGestureCallbackRef.current = setTimeout(() => {\n              onClose();\n\n              // Trigger an update after we dispatch the action to remove the screen\n              // This will make sure that we check if the screen didn't get removed so we can cancel the animation\n              forceUpdate();\n            }, 32);\n          }\n\n          onGestureEnd?.();\n          break;\n        }\n      }\n    }\n  );\n\n  React.useLayoutEffect(() => {\n    layoutAnim.width.setValue(layout.width);\n    layoutAnim.height.setValue(layout.height);\n    inverted.setValue(\n      getInvertedMultiplier(gestureDirection, direction === 'rtl')\n    );\n  }, [\n    gestureDirection,\n    direction,\n    inverted,\n    layoutAnim.width,\n    layoutAnim.height,\n    layout.width,\n    layout.height,\n  ]);\n\n  const previousPropsRef = React.useRef<{\n    opening: boolean;\n    closing: boolean;\n    layout: Layout;\n    direction: LocaleDirection;\n    gestureDirection: GestureDirection;\n    preloaded: boolean;\n  } | null>(null);\n\n  React.useEffect(() => {\n    return () => {\n      onEndInteraction();\n\n      if (animationHandleRef.current) {\n        cancelAnimationFrame(animationHandleRef.current);\n      }\n\n      clearTimeout(pendingGestureCallbackRef.current);\n    };\n\n    // We only want to clean up the animation on unmount\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n  }, []);\n\n  const timeoutRef = React.useRef<ReturnType<typeof setTimeout> | null>(null);\n\n  React.useEffect(() => {\n    if (preloaded) {\n      return;\n    }\n\n    if (!didInitiallyAnimate.current) {\n      // Animate the card in on initial mount\n      // Wrap in setTimeout to ensure animation starts after\n      // rending of the screen is done. This is especially important\n      // in the new architecture\n      // cf., https://github.com/react-navigation/react-navigation/issues/12401\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n      timeoutRef.current = setTimeout(() => {\n        didInitiallyAnimate.current = true;\n        animate({ closing });\n      }, 0);\n    } else {\n      const previousOpening = previousPropsRef.current?.opening;\n      const previousToValue = previousPropsRef.current\n        ? getAnimateToValue(previousPropsRef.current)\n        : null;\n\n      const toValue = getAnimateToValue({\n        closing,\n        layout,\n        gestureDirection,\n        direction,\n        preloaded,\n      });\n\n      if (previousToValue !== toValue || lastToValueRef.current !== toValue) {\n        // We need to trigger the animation when route was closed\n        // The route might have been closed by a `POP` action or by a gesture\n        // When route was closed due to a gesture, the animation would've happened already\n        // It's still important to trigger the animation so that `onClose` is called\n        // If `onClose` is not called, cleanup step won't be performed for gestures\n        animate({ closing });\n      } else if (\n        typeof previousOpening === 'boolean' &&\n        opening &&\n        !previousOpening\n      ) {\n        // This can happen when screen somewhere below in the stack comes into focus via rearranging\n        // Also reset the animated value to make sure that the animation starts from the beginning\n        gesture.setValue(\n          getDistanceForDirection(layout, gestureDirection, direction === 'rtl')\n        );\n\n        animate({ closing });\n      }\n    }\n\n    previousPropsRef.current = {\n      opening,\n      closing,\n      layout,\n      gestureDirection,\n      direction,\n      preloaded,\n    };\n  }, [\n    animate,\n    closing,\n    direction,\n    gesture,\n    gestureDirection,\n    layout,\n    opening,\n    preloaded,\n  ]);\n\n  const interpolationProps = React.useMemo(\n    () => ({\n      index: interpolationIndex,\n      current: { progress: current },\n      next: next && { progress: next },\n      closing: isClosing,\n      swiping: isSwiping,\n      inverted,\n      layouts: {\n        screen: layout,\n      },\n      insets: {\n        top: insets.top,\n        right: insets.right,\n        bottom: insets.bottom,\n        left: insets.left,\n      },\n    }),\n    [\n      interpolationIndex,\n      current,\n      next,\n      isClosing,\n      isSwiping,\n      inverted,\n      layout,\n      insets.top,\n      insets.right,\n      insets.bottom,\n      insets.left,\n    ]\n  );\n\n  const { containerStyle, cardStyle, overlayStyle, shadowStyle } =\n    React.useMemo(\n      () => styleInterpolator(interpolationProps),\n      [styleInterpolator, interpolationProps]\n    );\n\n  const onGestureEvent = React.useMemo(\n    () =>\n      gestureEnabled\n        ? Animated.event(\n            [\n              {\n                nativeEvent:\n                  gestureDirection === 'vertical' ||\n                  gestureDirection === 'vertical-inverted'\n                    ? { translationY: gesture }\n                    : { translationX: gesture },\n              },\n            ],\n            { useNativeDriver }\n          )\n        : undefined,\n    [gesture, gestureDirection, gestureEnabled]\n  );\n\n  const { backgroundColor } = StyleSheet.flatten(contentStyle || {});\n\n  const isTransparent =\n    typeof backgroundColor === 'string'\n      ? Color(backgroundColor).alpha() === 0\n      : false;\n\n  return (\n    <CardAnimationContext.Provider value={interpolationProps}>\n      {Platform.OS !== 'web' ? (\n        <Animated.View\n          style={{\n            // This is a dummy style that doesn't actually change anything visually.\n            // Animated needs the animated value to be used somewhere, otherwise things don't update properly.\n            // If we disable animations and hide header, it could end up making the value unused.\n            // So we have this dummy style that will always be used regardless of what else changed.\n            opacity: current,\n          }}\n          // Make sure that this view isn't removed. If this view is removed, our style with animated value won't apply\n          collapsable={false}\n        />\n      ) : null}\n      {overlayEnabled ? (\n        <View pointerEvents=\"box-none\" style={StyleSheet.absoluteFill}>\n          {overlay({ style: overlayStyle })}\n        </View>\n      ) : null}\n      <Animated.View\n        pointerEvents=\"box-none\"\n        style={[styles.container, containerStyle, customContainerStyle]}\n      >\n        <PanGestureHandler\n          enabled={layout.width !== 0 && gestureEnabled}\n          onGestureEvent={onGestureEvent}\n          onHandlerStateChange={onGestureStateChange}\n          {...gestureActivationCriteria({\n            layout,\n            direction,\n            gestureDirection,\n            gestureResponseDistance,\n          })}\n        >\n          <Animated.View\n            pointerEvents=\"box-none\"\n            needsOffscreenAlphaCompositing={hasOpacityStyle(cardStyle)}\n            style={[styles.container, cardStyle]}\n          >\n            {shadowEnabled && shadowStyle && !isTransparent ? (\n              <Animated.View\n                pointerEvents=\"none\"\n                style={[\n                  styles.shadow,\n                  gestureDirection === 'horizontal'\n                    ? [styles.shadowHorizontal, styles.shadowStart]\n                    : gestureDirection === 'horizontal-inverted'\n                      ? [styles.shadowHorizontal, styles.shadowEnd]\n                      : gestureDirection === 'vertical'\n                        ? [styles.shadowVertical, styles.shadowTop]\n                        : [styles.shadowVertical, styles.shadowBottom],\n                  { backgroundColor },\n                  shadowStyle,\n                ]}\n              />\n            ) : null}\n            <CardContent\n              enabled={pageOverflowEnabled}\n              layout={layout}\n              style={contentStyle}\n            >\n              {children}\n            </CardContent>\n          </Animated.View>\n        </PanGestureHandler>\n      </Animated.View>\n    </CardAnimationContext.Provider>\n  );\n}\n\nexport { Card };\n\nconst styles = StyleSheet.create({\n  container: {\n    flex: 1,\n  },\n  overlay: {\n    flex: 1,\n    backgroundColor: '#000',\n  },\n  shadow: {\n    position: 'absolute',\n  },\n  shadowHorizontal: {\n    top: 0,\n    bottom: 0,\n    width: 3,\n    ...getShadowStyle({\n      offset: {\n        width: -1,\n        height: 1,\n      },\n      radius: 5,\n      opacity: 0.3,\n    }),\n  },\n  shadowStart: {\n    start: 0,\n  },\n  shadowEnd: {\n    end: 0,\n  },\n  shadowVertical: {\n    start: 0,\n    end: 0,\n    height: 3,\n    ...getShadowStyle({\n      offset: {\n        width: 1,\n        height: -1,\n      },\n      radius: 5,\n      opacity: 0.3,\n    }),\n  },\n  shadowTop: {\n    top: 0,\n  },\n  shadowBottom: {\n    bottom: 0,\n  },\n});\n"],"mappings":"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","ignoreList":[]},"metadata":{"hasCjsExports":false},"sourceType":"module","externalDependencies":[]}